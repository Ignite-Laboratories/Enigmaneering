# `E0S1.1 - Primitive Parity Printing`
### `Alex Petz, Ignite Laboratories, March 2025`

---

### What is this example doing?

Well, simply put: it counts to approximately 20 and tells you the number's parity (_even_ or _odd_).  
In reality, it's doing so much more under the hood to facilitate this.

Let's break it down step by step -

    main() -
	    core.Impulse.Loop(Hold, condition.Always, false)

    ...

    func Hold(ctx core.Context) {
        time.Sleep(time.Second * 5)
    }

The first thing you will find is `core.Impulse` - the globally available _impulse engine_ for all
JanOS instances.  For now, we will focus entirely around _this_ impulse engine - but, just be aware
that an instance can have as many impulse engines as it likes.  You are _not_ required to utilize
only the core impulse engine.

The hold function simply sleeps, allowing the impulse engine to keep counting up beats.  Since the impulse 
rate is slow, all neural activation completes before the next impulse - thus, the next beat resets to _0_.

The rest of the above is quite straightforward - we create a _looping neural activation_ that fires 
the `Hold` function on every impulse.  It accomplishes this through a package called `condition` which 
provides some basic helper **Potentials**.  This is one of the most _crucial_ concepts of neural 
execution - _every action fires after testing a potential function._  For every impulse of the engine 
neurons are tested for activation using a provided function.

    tl;dr - the Hold function is always activated by the neuron when impulsed

The final parameter is a boolean that indicates if the neuron should be _muted_ upon creation. I'll
expand more on the function of muting later on, for now let's continue to the next two neurons -

    main() -
        core.Impulse.Stimulate(func(ctx core.Context) {
            PrintParity(ctx, "Even")
        }, beat.Even, false)
    
        core.Impulse.Stimulate(func(ctx core.Context) {
            PrintParity(ctx, "Odd")
        }, beat.Odd, false)

    ...

    func PrintParity(ctx core.Context, parity string) {
        fmt.Printf("%d - %v\n", ctx.Beat, parity)
    }

Here is one of the most powerful ways of creating impulsive stimulations - through inline anonymous
functions!  Here, both neurons are utilizing the same underlying function - `PrintParity` - but each
is uniquely modifying how it invokes it when stimulated.

The next thing you will find is a less common package called `beat` that provides helper potentials
just as the `condition` package does; however, these are oriented towards _beat-specific_ potentials.
I say it's less common because _live_ systems typically won't leverage _beat_ potentials, by design.
We'll talk about how _static_ neural activation later.

    tl;dr - anonymous functions can be used to inject information into an activation thread

Let's continue -

    main() - 
        core.Impulse.MaxFrequency = 4

This sets the maximum impulse rate of the engine to `4hz`. The maximum impulse frequency can be used 
to directly slow neural activation _without_ adding temporal weight.  This effectively _limits_ the 
rate of impulse.

To add temporal weight, impulse engines also have a `Resistance` value which can _throttle_ 
every impulse.  It's quite primitive in execution, but _very_ effective.  This is it's implementation - 

	main() -
        core.Impulse.Resistance = 800000000

    core.NewEngine() -
        regulator := func(ctx Context) {
            for i := 0; i < engine.Resistance; i++ {
            }
        }
        engine.Block(regulator, condition.Always, false)

This method, however, _doesn't_ provide any guarantees of frequency!  Instead, it provides a _control
surface_ through which a system can regulate _itself_.  The concept of _control surfaces_ will
echo a lot as we progress into this project.  A control surface simply provides a mechanism for 
intra-activation control.  Here, resistance can be increased by the very activations driven by the engine.  

It's an _entirely abstract_ concept - one that can be imbued upon anything through using intentional terminology!

    tl;dr - using good terminology empowers the next enigmaneer to instinctively know what something does

Lastly we call the most important method of the entire ecosystem -

    // Make it so
    core.Impulse.Spark()

Simply put, this is what begins neural execution of an impulse engine =)