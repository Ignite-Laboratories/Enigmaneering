# `E2S2.2 - Again from the Top`
### `Alex Petz, Ignite Laboratories, April 2025`

---

### Self-sufficient Code
Alright, now that we have _firmly_ established how to interface with X11 and bridge it with EGL, it's time to
completely rewrite the X11 code!  Why?  Because the code we were importing was only a _facade_ that abstracted
away what X11 was actually doing.  Instead of relying upon a third party library, let's just bridge the gap
to X11 ourselves!  I promise it's far less daunting than you might think, thanks to Go's tight coupling with C -

    /*
    #cgo LDFLAGS: -lX11
    #include <X11/Xlib.h>
    #include <X11/Xatom.h>
    #include <stdlib.h>
    */
    import "C"
    
    func main() {
        C.XOpenDisplay(nil)
    }

You can call C functions from the included libraries _directly!_  Everything good comes with a detriment, though.
The issue here is that the C code is _locally scoped_ to this file, and if you try to reference the types
generated by this file in another package they will _not_ play nicely together.  Fortunately, that's easy to
resolve by using _wrappers_ - 

    type Display = *C.Display
    
    func (w *Wrapper) Flush(display *Display) {
        C.XFlush(display)
    }

Here we have _aliased_ the C type `Display` to a well-defined Go type and can provide it to functions as such.
By moving to _this_ paradigm of "wrapping" our calls to C, we can treat them as if they are Go functions!
This means that we have _full control_ over the threading model and how to interface with the C tools, which
is absolutely _wonderful._  

Because of this we can eliminate our tie to the `jezek/xgb` library entirely, while also gaining much tighter
access to X11 constructs.  In doing so, I fleshed out a number of the X11 functions into a package called `x11`
in the `host` module.  This allowed me to rewrite the mouse observance functionality to capture much richer
information - here's it's implementation, currently -

    package x11

    // QueryPointer retrieves the pointer's current position and its relationship to the specified window.
    func QueryPointer(display *Display, window Window) (PointerQuery, error) {
        // Prepare C variables for receiving data
        var rootReturn, childReturn C.Window
        var rootXReturn, rootYReturn C.int
        var winXReturn, winYReturn C.int
        var maskReturn C.uint
    
        // Call XQueryPointer
        success := C.XQueryPointer(
            display.ptr,  // Display pointer
            window.ID,    // Window ID to query
            &rootReturn,  // Pointer to receive parent (root) window
            &childReturn, // Pointer to receive child window
            &rootXReturn, // Pointer to root X coordinate
            &rootYReturn, // Pointer to root Y coordinate
            &winXReturn,  // Pointer to window-relative X coordinate
            &winYReturn,  // Pointer to window-relative Y coordinate
            &maskReturn,  // Pointer to receive button/key mask
        )
    
        // If XQueryPointer returns 0, it failed
        if success == 0 {
            return PointerQuery{}, errors.New("XQueryPointer failed to query pointer position")
        }
    
        // Convert the query to a std.MouseState structure
        query := PointerQuery{
            Parent: Window{ID: rootReturn},
            Child:  Window{ID: childReturn},
            RootX:  int(rootXReturn),
            RootY:  int(rootYReturn),
            WinX:   int(winXReturn),
            WinY:   int(winYReturn),
            Mask:   uint(maskReturn),
        }
    
        return query, nil
    }

I also built a basic type in the `std` package to support passing general mouse state information around - 

    package std
    
    // MouseState provides the current state of the mouse.
    type MouseState struct {
        Position XY[int]
        Buttons        struct {
            Left, Middle, Right bool
        }
    }

And lastly, a simple method for converting the query type to our standard type.  If you pass true to the
method, it 

    func XPointerQueryToState(query x11.PointerQuery, relative bool) (state std.MouseState) {
        if relative {
            state.Position = std.XY[int]{
                X: query.RootX,
                Y: query.RootY,
            }
        } else {
            state.Position = std.XY[int]{
                X: query.WinX,
                Y: query.WinY,
            }
        }
    
        if query.Mask&x11.Button1Mask != 0 {
            state.Buttons.Left = true
        }
        if query.Mask&x11.Button2Mask != 0 {
            state.Buttons.Middle = true
        }
        if query.Mask&x11.Button3Mask != 0 {
            state.Buttons.Right = true
        }
    
        return state
    }

### X11 Window Management
Since the code for window management hasn't changed _terribly_ from the implementation before, I'll provide
an abridged example of the new process.  First, we create a type that handles X11 windows - this will
include pointer references to the window, itself, and the X11 display connection -

    type Handle struct {
        core.Entity
        Display *x11.Display
        Window  *x11.Window
    }

Next, we setup a map to identify these handles by their entity identifier -
    
    var Handles = make(map[uint64]Handle)

And then we provide a way to create windows and populate the handle map.  Note that, in this abridged
example, I am explicitly _ignoring_ errors back from the x11 calls for simplicity.  Please ensure
you perform proper error checking in your own implementation, as I have in the production code -

    func Create(size std.XY[int]) Handle {
        runtime.LockOSThread()

        display, _ := x11.OpenDisplay()
    
        // Create the window
        window, _ := x11.CreateWindow(display, 0, 0, size.X, size.Y)
    
        // Map the new window to an entity ID
        handle := Handle{Display: display, Window: window}
        handle.ID = core.NextID()
        Handles[handle.ID] = handle
    
	    // Enable detection of a 'close' event
        x11.SelectInput(display, window, x11.StructureNotifyMask) 
        x11.SetWindowProtocols(display, window)
    
        // Show the window
        x11.ShowWindow(display, window)
    
        // Process events in the background
        go handleEvents(handle)
    
        return handle
    }

Lastly, we have to handle general events from the display connection -

    func handleEvents(handle Handle) {
        for core.Alive {
            // Wait for the next event and retrieve it
            e, err := x11.WaitForEvent(handle.Display)
            if err != nil {
                continue
            }
    
            switch e.Type {
            case x11.ClientMessage:
                // Retrieve the window and message data
                window := x11.GetEventWindow(e)
                data, _ := x11.GetClientMessageData(e)
    
                // Are we closing the window?
                wmDeleteAtom := x11.GetAtom(handle.Display, x11.WMDeleteWindow) 
                if x11.Atom(data[0]) == wmDeleteAtom {
                    // Then, destroy it
                    x11.DestroyWindow(handle.Display, window)
                    x11.Flush(handle.Display)
                    delete(Handles, handle.ID)
                }
            }
        }
    }

While the X11 wrapper code has added a bit more complexity to the general project size, I think you'll
agree that the _direct_ access to X11 calls was absolutely worth the effort =)  