# `E1S0.2 - Distillation`
### `Alex Petz, Ignite Laboratories, May 2025`

---

### Algorithmic Encoding
Okay, let's get down to brass tacks - how do we approximate a file?

By exploiting the fact that we know the bounds the file exists _within_ - specifically, its bit length!

For example, let's distill the below byte:

    [ 1 0 1 0 1 0 1 0 ]

It's value is 8 bits long, meaning its _below_ 2⁸ (or 256).

Let's subdivide 256 by a crumb (2 bits, or 4 unique values) - which quadrant does the value exist within?

            "Light" Value ⬎                     ⬐ "Dark" Value
      0 -  63 - [ 0 0 0 0 0 0 0 0 ] - [ 0 0 1 1 1 1 1 1 ]
     64 - 127 - [ 0 1 0 0 0 0 0 0 ] - [ 0 1 1 1 1 1 1 1 ]
    128 - 191 - [ 1 0 0 0 0 0 0 0 ] - [ 1 0 1 1 1 1 1 1 ]
    192 - 255 - [ 1 1 0 0 0 0 0 0 ] - [ 1 1 1 1 1 1 1 1 ]

Comparing the first quadrant to the byte, it's easy to see that's where it exists within:

    [ 1 0 0 0 0 0 0 0 ] <- 128
    [ 1 0 1 0 1 0 1 0 ] <- Value (170) 
    [ 1 0 1 1 1 1 1 1 ] <- 191

This means we can _safely_ subtract 128 from the target byte while saving off a crumb indicating quadrant
3 was identified.

    [ 1 0 1 0 1 0 ] <- Result (42)
            [ 1 0 ] <- Timeline Entry

From here, we need to track the reduction in bits, which in the above case is 2.

    [ 1 1 0 ] <- Delta 5-bit ZLE

This yields a resulting timeline of:

       ⬐ Value (2)      ⬐ Remainder
    | 1 0 | 1 1 0 | 1 0 1 0 1 0 |
              ⬑ Delta (2 bits)

While this example doesn't shrink the total bit length, it should demonstrate the concept!

In fact, until this is used _at scale_ it would never yield a shorter bit-length =)