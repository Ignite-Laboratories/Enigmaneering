# `E1S0.0 - Zero Length Encoding`
### `Alex Petz, Ignite Laboratories, May 2025`

---

### Minimizing Used Bits
One of the most important goals of a binary synthesis scheme is to do so in _as few bits as possible._  To
accomplish this, we need to be able to reference numbers (which are just measurements) of arbitrary bit-lengths
that can dynamically change based on context.  While that may sound like a tall order, it's not so difficult
if you consider the _bounds_ the goal defines.

    tl;dr - how many bit lengths are reasonably necessary?

Well, as I mentioned before, we have a _practical infinity_ we get to use for approximation - 2⁶⁴ bits.  Since
we're identifying variable regions of abstract data, we shouldn't ever need to store a value that requires more 
than 64 bits to be addressed - giving us an upper maximum of 64 bits (2⁵) we'll reasonably need to encode at a time.

That leaves us with a range of five bits to cover - but we want to _maximize_ the reduction for smaller bit lengths!

So - rather than relying on a fixed width set of bits I developed the below scheme I call "Zero Length Encoding".

This comes in three different flavors, for three different use cases and scales - the first is the most simple:

**Standard Zero Length Encoding (ZLE)**

    Read until you reach a 1 and count the number of zeros read as '𝑛'.

    Then, read 2ⁿ more bits to retrieve the encoded value.

    If 𝑛 is 0, 0 bits should be read.

        Key   | 𝑛-Bit Range
            1 | Read 0 bits
          0 1 | Read 2¹ (2) more bits
        0 0 1 | Read 2² (4) more bits
      0 0 0 1 | Read 2³ (8) more bits
    0 0 0 0 1 | Read 2⁴ (16) more bits

While this is the most idiomatic, it's also not very useful.  It would be much better if we capped the amount
of available options to _five,_ as this gives us the ability to reference any number between 0-2⁶⁴ - thus,
the next two ZLE flavors are what do the majority of the heavy lifting:

**64-bit ZLE**

    Read until you reach a 1 (up to 4 bits) and count the number of zeros read as '𝑛'.

    If four bits are found and the last is 1 then '𝑛' should equal '5'.

    Finally, read 2ⁿ⁺¹ more bits to retrieve the encoded value.

       Key  | 𝑛-Bit Range
          1 | Read a 4 bit value
        0 1 | Read a 8 bit value
      0 0 1 | Read a 16 bit value
    0 0 0 0 | Read a 32 bit value
    0 0 0 1 | Read a 64 bit value

**5-bit ZLE**

    Read until you reach a 1 (up to 4 bits) and count the number of zeros read as '𝑛'.

    If four bits are found and the last is 1 then '𝑛' should equal '5'.

    Finally, read 𝑛 more bits to retrieve the encoded value.

       Key  | 𝑛-Bit Range
          1 | Read a 1 bit value
        0 1 | Read a 2 bit value
      0 0 1 | Read a 3 bit value
    0 0 0 0 | Read a 4 bit value
    0 0 0 1 | Read a 5 bit value