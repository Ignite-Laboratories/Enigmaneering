# `E1S0.0 - Zero Length Encoding`
### `Alex Petz, Ignite Laboratories, May 2025`

---

### Minimizing Used Bits
One of the most important goals of a binary synthesis scheme is to do so in _as few bits as possible._  To
accomplish this, we need to be able to reference numbers (which are just measurements) of arbitrary bit-lengths
that can dynamically change based on context.  While that may sound like a tall order, it's not so difficult
if you consider the _bounds_ the goal defines.

    tl;dr - how many bit lengths are reasonably necessary?

Well, as I mentioned before, we have a _practical infinity_ we get to use for approximation - 2â¶â´ bits.  Since
we are _not_ encoding any values, rather approximating ranges of binary information, why would we _ever_ need
to store a value that requires more than 64 bits to be addressed?

Okay - so then what is our _minimum_ value that we wish to encode?  Is it 1 bit wide?  No, that already self-describes.
2 bits wide would be our reasonable minimum, in that case, for an _encoded_ measurement.

That leaves us with a range of five bits to cover - but we want to _maximize_ the reduction for smaller bit lengths!

So - rather than relying on a fixed width set of bits I developed the below scheme I call "Zero Length Encoding":

    Z.L.E.

    Read until you reach a 1 (up to 4 bits) and count the number of zeros read as 'ğ‘›'.

    If four bits are found and the last is 1 then 'ğ‘›' should equal '5'.

    Finally, read 2â¿âºÂ¹ more bits to retrieve the encoded value.

       Key  | ğ‘›-Bit Range
          1 | Read a 4 bit value
        0 1 | Read a 8 bit value
      0 0 1 | Read a 16 bit value
    0 0 0 0 | Read a 32 bit value
    0 0 0 1 | Read a 64 bit value

### Micro Z.L.E.
This kind of encoding comes in two particular flavors - full scale (as above) and _micro_ scaling.  The
difference is simple - the values are read as 1:1 rather than a power of 2.

       Key  | ğ‘›-Bit Range
          1 | Read a 1 bit value
        0 1 | Read a 2 bit value
      0 0 1 | Read a 3 bit value
    0 0 0 0 | Read a 4 bit value
    0 0 0 1 | Read a 5 bit value