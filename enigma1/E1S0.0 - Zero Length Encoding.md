# `E1S0.0 - Zero Length Encoding`
### `Alex Petz, Ignite Laboratories, May 2025`

---

### Minimizing Used Bits
One of the most important goals of a binary synthesis scheme is to do so in _as few bits as possible._  To
accomplish this, we need to be able to reference numbers (which are just measurements) of arbitrary bit-lengths
that can dynamically change based on context.  While that may sound like a tall order, it's not so difficult
if you consider the _bounds_ the goal defines.

    tl;dr - how many bit lengths are reasonably necessary?

Well, as I mentioned before, we have a _practical infinity_ we get to use for approximation - 2⁶⁴ bits.  Since
we're identifying variable regions of abstract data, we shouldn't ever need to store a value that requires more 
than 64 bits to be addressed - giving us an upper maximum of 64 bits (2⁵) we'll reasonably need to encode at a time.

That leaves us with a range of five bits to cover - but we want to _maximize_ the reduction for smaller bit lengths!

So - rather than relying on a fixed width set of bits I developed the below scheme I call "Zero Length Encoding":

    Z.L.E.

    Read until you reach a 1 (up to 4 bits) and count the number of zeros read as '𝑛'.

    If four bits are found and the last is 1 then '𝑛' should equal '5'.

    Finally, read 2ⁿ⁺¹ more bits to retrieve the encoded value.

       Key  | 𝑛-Bit Range
          1 | Read a 4 bit value
        0 1 | Read a 8 bit value
      0 0 1 | Read a 16 bit value
    0 0 0 0 | Read a 32 bit value
    0 0 0 1 | Read a 64 bit value

### Micro and Macro Z.L.E.
This kind of encoding comes in three particular flavors - standard (as above) and _Micro_ or _Macro_ scaling.

The differences are simple - for Micro Z.L.E. the values are read as 1:1 rather than a power of 2.

       Key  | 𝑛-Bit Range
          1 | Read a 1 bit value
        0 1 | Read a 2 bit value
      0 0 1 | Read a 3 bit value
    0 0 0 0 | Read a 4 bit value
    0 0 0 1 | Read a 5 bit value  

For Macro Z.L.E. the number of zeros indicates the power of two worth of bits to read.

       Key  | 2ⁿ-Bit Range
          1 | Read a 0 (2⁰) bit value
        0 1 | Read a 2 (2¹) bit value
      0 0 1 | Read a 4 (2²) bit value
    0 0 0 1 | Read a 8 (2³) bit value
            ...
        𝑛 1 | Read a 2ⁿ bit value