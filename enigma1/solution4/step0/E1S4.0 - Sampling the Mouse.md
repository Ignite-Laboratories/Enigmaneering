# `E1S4.0 - Sampling the Mouse`
### `Alex Petz, Ignite Laboratories, March 2025`

---

### Derived Dimensions
As we continue to explore how to derive dimensions from one another we need something more interesting
to calculate off of.  Rather than continuing with such contrived examples, let's start working towards
a goal: intelligent reactions to stimulated input!  The easiest input to capture would be
the _mouse position,_ with one minor caveat - Go doesn't natively provide a way to capture the mouse
information!  Thankfully, JanOS has another module that provides such access - `host`

If you'd like to read more about how it's implemented, check out `enigma2` =)

### Mouse
For our first task, we need to sample some input.  `host` provides an easy (and cross-platform) way to 
just _sample_ the mouse coordinates on demand, but we can grab it in three ways -

    Through a new observer -
        temporal.Observer(core.Impulse, when.Frequency(&mouse.SampleRate), false, mouse.SampleCoordinates)

    By un-muting the global mouse coordinate observer -
        func init() {
            mouse.Coordinates.Unmute()
        }

    Through a point calculation -
        temporal.Calculation(core.Impulse, when.Frequency(&mouse.SampleRate), false, CalcCoords)
        func CalcCoords(ctx core.Context) std.XY[int] {
            return *mouse.SampleCoordinates()
        }

All three yield the same result, but the _point calculation_ provides a way to inject some kind of condition
into the observation.  Creating an observational dimension for other dimensions to derive from is perfectly
acceptable, but performing calculations directly is more efficient.  Let's change `CalcCoords` to check if 
the mouse is on the "left" of the screen and print the coordinates out, otherwise do nothing.

    func CalcCoords(ctx core.Context) std.XY[int] {
        coords := mouse.SampleCoordinates()
        if coords.X < 1024 {
            fmt.Println(coords)
        }
        return *coords
    }

The above function type is a `PointCalculation` function signature - it's meant to generate a value _in
good timing_ with your overall system architecture -

    type PointCalculation[T any] func(core.Context) T