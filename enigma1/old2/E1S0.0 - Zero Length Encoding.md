# `E1S0.0 - Zero Length Encoding`
### `Alex Petz, Ignite Laboratories, May 2025`

---

### Minimizing Used Bits
One of the most important goals of a binary synthesis scheme is to do so in _as few bits as possible._  To
accomplish this, we need to be able to reference numbers (which are just measurements) of arbitrary bit-lengths
that can dynamically change based on context.  While that may sound like a tall order, it's not so difficult
if you consider the _bounds_ the goal defines.

    tl;dr - how many bit lengths are reasonably necessary?

Well, as I mentioned before, we have a _practical infinity_ we get to use for approximation - 2â¶â´ bits.  Since
we're identifying variable regions of abstract data, we shouldn't ever need to store a value that requires more 
than 64 bits to be addressed - giving us an upper maximum of 64 bits (2âµ) we'll reasonably need to encode at a time.

That leaves us with a range of five bits to cover - but we want to _maximize_ the reduction for smaller bit lengths!

So - rather than relying on a fixed width set of bits I developed the below scheme I call "Zero Length Encoding".

This comes in three different flavors, for three different use cases and scales - the first is the most simple:

**Standard Zero Length Encoding (ZLE)**

    Read until you reach a 1 and count the number of zeros read as 'ğ‘›'.

    Then, read 2â¿ more bits to retrieve the encoded value.

    If ğ‘› is 0, 0 bits should be read.

        Key   | ğ‘›-Bit Range
            1 | Read 0 bits
          0 1 | Read 2Â¹ (2) more bits
        0 0 1 | Read 2Â² (4) more bits
      0 0 0 1 | Read 2Â³ (8) more bits
    0 0 0 0 1 | Read 2â´ (16) more bits

While this is the most idiomatic, it's also not very useful.  It would be much better if we capped the amount
of available options to _five,_ as this gives us the ability to reference any number between 0-2â¶â´ - thus,
the next two ZLE flavors are what do the majority of the heavy lifting:

**64-bit ZLE**

    Read until you reach a 1 (up to 4 bits) and count the number of zeros read as 'ğ‘›'.

    If four bits are found and the last is 1 then 'ğ‘›' should equal '5'.

    Finally, read 2â¿âºÂ¹ more bits to retrieve the encoded value.

       Key  | ğ‘›-Bit Range
          1 | Read a 4 bit value
        0 1 | Read a 8 bit value
      0 0 1 | Read a 16 bit value
    0 0 0 0 | Read a 32 bit value
    0 0 0 1 | Read a 64 bit value

**5-bit ZLE**

    Read until you reach a 1 (up to 4 bits) and count the number of zeros read as 'ğ‘›'.

    If four bits are found and the last is 1 then 'ğ‘›' should equal '5'.

    Finally, read ğ‘› more bits to retrieve the encoded value.

       Key  | ğ‘›-Bit Range
          1 | Read a 1 bit value
        0 1 | Read a 2 bit value
      0 0 1 | Read a 3 bit value
    0 0 0 0 | Read a 4 bit value
    0 0 0 1 | Read a 5 bit value